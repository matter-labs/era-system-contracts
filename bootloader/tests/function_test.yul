
// This stuff will be in testing_utils.yul
function testLog(msg, data) {
    storeVmHookParam(0, nonOptimized(msg))
    storeVmHookParam(1, nonOptimized(data))
    setHook(nonOptimized(100))
}

function testing_assertEq(a, b, message) {
    if iszero(eq(a, b)) {
        storeVmHookParam(0, nonOptimized(a))
        storeVmHookParam(1, nonOptimized(b))
        // Hack...
        storeVmHookParam(3, nonOptimized(message))
        setHook(nonOptimized(101))
    }
}
function testing_testWillFailWith(message) {
    storeVmHookParam(0, unoptimized(message))
    setHook(nonOptimized(102))
}
function testing_totalTests(tests) {
    storeVmHookParam(0, unoptimized(tests))
    setHook(nonOptimized(103))
}


// Types of tests:
//    - 'static' - that just test the 'stateless' functions, should be run before any 'init' stuff - and simply call 'return'
//   --- how to test functions that depend on stuff in memory? (like transaction info??)n
//                    -- maybe have some transactoins that they can 'request to be inserted'??
//   --- how to test functions that call stuff?

function TEST_safeSub() {
    testLog("Starting test safeSub", 0x1)
    testing_assertEq(safeSub(10, 7, "err"), 3, "Failed to subtract 7")
    testing_assertEq(safeSub(10, 8, "err"), 2, "Failed to subtract 8")
}

function TEST_asserts() {
    testLog("Starting test asserts", 0x1)
    testing_testWillFailWith("willFail")
    safeSub(10, 12, "willFail")
}




// This block will be auto generated by typescript preprocessing.
let test_id := mload(0)

switch test_id 
    case 0 {
        testing_totalTests(2)
    }
    case 1 {
        TEST_safeSub()
    }
    case 2 {
        TEST_asserts()
    }
    default {
    }



return(0, 0)
